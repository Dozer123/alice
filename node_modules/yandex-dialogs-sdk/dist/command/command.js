"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fast_levenshtein_1 = __importDefault(require("fast-levenshtein"));
const constants_1 = require("../constants");
const inBetween = (from, to) => (value) => Math.max(from, Math.min(value, to));
const getLevenshteinRelevance = (a, b) => inBetween(0, 1)(1 - fast_levenshtein_1.default.get(a, b) / Math.max(a.length, b.length));
class Command {
    constructor(matcher, callback) {
        this._matcher = matcher;
        this._callback = callback;
    }
    async getRelevance(context) {
        return this._matcher.call(null, context);
    }
    async run(context) {
        return this._callback.call(null, context);
    }
    static createCommand(declaration, callback) {
        if (typeof declaration === 'function') {
            return new Command(declaration, callback);
        }
        if (typeof declaration === 'string') {
            return new Command(this.createMatcherFromString(declaration), callback);
        }
        if (Array.isArray(declaration)) {
            return new Command(this.createMatcherFromStrings(declaration), callback);
        }
        if (declaration instanceof RegExp) {
            return new Command(this.createMatcherFromRegExp(declaration), callback);
        }
        throw new Error('Command declaration is not of proper type. ' +
            'Could be only string, array of strings, RegExp or function.');
    }
    static createMatcherFromString(string) {
        if (!string) {
            return () => 0;
        }
        return (context) => {
            const commandText = context.data.request.command;
            const lowerMessage = commandText ? commandText.toLowerCase() : '';
            /*
             * Calculating Levenshtein distance between 2 strings
             * More info: https://en.wikipedia.org/wiki/Levenshtein_distance
             */
            const relevance = getLevenshteinRelevance(string, lowerMessage);
            return relevance >= constants_1.LEVENSHTEIN_MATCH_THRESHOLD ? relevance : 0;
        };
    }
    static createMatcherFromStrings(strings) {
        if (!strings || !strings.length) {
            return () => 0;
        }
        const lowerStrings = strings.map(s => s.toLowerCase());
        return (context) => {
            const commandText = context.data.request.command;
            const lowerMessage = commandText ? commandText.toLowerCase() : '';
            return lowerStrings.some(s => s === lowerMessage) ? 1 : 0;
        };
    }
    static createMatcherFromRegExp(regexp) {
        return (context) => {
            const commandText = context.data.request.command;
            const lowerMessage = commandText ? commandText.toLowerCase() : '';
            return regexp.test(lowerMessage) ? 1 : 0;
        };
    }
    static createMatcherAlways() {
        return () => 1;
    }
    static createMatcherNever() {
        return () => 0;
    }
}
exports.Command = Command;
